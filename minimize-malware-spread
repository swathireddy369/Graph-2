// Time Complexity :O(n*n)
// Space Complexity :O(n)
// Did this code successfully run on Leetcode :yes
// Any problem you faced while coding this :no
// Your code here along with comments explaining your approach:

class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        int[] colors = new int[n];
        Arrays.fill(colors, -1);//filling all nodes with -1 color
        int color = 0;//starting with 0 color
        for (int i = 0; i < n; i++) {//starting with 0 row
            dfs(graph, i, color, colors);//coloring all connected nodes for 0 with same color
            color++; //incrementing the color count
        }
        int[] groups = new int[color];//groups array to maintains number of nodes belongs to particular group
        int[] initGroup = new int[color];//number of infected nodes for particular color group
        //O(n)
        for (int i = 0; i < n; i++) {//number of nodes in particular group
            int col = colors[i];
            groups[col]++;
        }
        //O(n) //woresr case all are infected 
        for (int node : initial) {//number of infected nodes in particulr group
            int c = colors[node];
            initGroup[c]++;
        }
        int result = Integer.MAX_VALUE;
        //O(n)
        for (int node : initial) {//initial array
            int col = colors[node];//getting color of particular infeced node
            int count = initGroup[col];//getting infected count of that particular group
            if (count == 1) {//only if infected count particular became one
                if (result == Integer.MAX_VALUE) {
                    //first occurance where we the infected node count 1
                    result = node;
                } else if (groups[col] > groups[colors[result]]) {
                    //where current is saving more nodes than result
                    result = node;
                } else if (groups[col] == groups[colors[result]] && node < result) {
                    //current and result both are saving same number of nodes so that we need to take min index among both so checking weathe rits less than result or not
                    result = node;
                }
            }

        }
        //no group has 1 infected count at that point of time just taking min node among all initial array
        if (result == Integer.MAX_VALUE) {
            for (int node : initial) { //O(n)
                result = Math.min(node, result);
            }
        }
        return result;
    }

    //O(n*n)
    public void dfs(int[][] graph, int i, int color, int[] colors) {
        //base
        if (colors[i] != -1)//aready colored
            return;
        //logic
        colors[i] = color;
        for (int j = 0; j < graph.length; j++) {
            if (graph[i][j] == 1) {//if it is connected 
                dfs(graph, j, color, colors);//coloring j th node as same color
            }
        }
    }
}